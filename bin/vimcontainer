#!/bin/bash
# Absolute path to this script
SCRIPT=$(readlink -f "$0")
# Absolute path this script is in
SCRIPT_DIR=$(dirname "$SCRIPT")
# Project root directory (parent of bin/)
PROJECT_ROOT=$(dirname "$SCRIPT_DIR")
# Devcontainers templates directory
DEVCONTAINERS_DIR="$PROJECT_ROOT/devcontainers"
# Common features path
COMMON_FEATURES_FILE="$DEVCONTAINERS_DIR/common/features.json"

# Usage: vimcontainer [options] <image_name> <workspace_path>
#        vimcontainer [options] <image_name_or_path> [workspace_path]
# Options:
#   -r, --rebuild: Rebuild the container
#
# Arguments:
#   image_name_or_path: Either:
#                       - Name of devcontainer template (e.g., 'dotnet', 'react')
#                       - Path containing .devcontainer folder (legacy mode)
#   workspace_path: Path to use as workspace in the container (default: current directory)
#
# Examples:
#   vimcontainer dotnet .                    # Use dotnet template with current dir
#   vimcontainer dotnet ~/my-project         # Use dotnet template with specified project
#   vimcontainer ~/custom/.devcontainer ~/project  # Use custom devcontainer (legacy)

# Parse arguments
rebuild_flag=""
while [[ "$1" =~ ^- ]]; do
    case "$1" in
        -r|--rebuild)
            rebuild_flag="--remove-existing-container"
            shift
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

IMAGE_NAME_OR_PATH="$1"
WORKSPACE_PATH="${2:-.}"

# Validate arguments
if [ -z "$IMAGE_NAME_OR_PATH" ]; then
    echo "Usage: vimcontainer [options] <image_name_or_path> [workspace_path]"
    echo ""
    echo "Options:"
    echo "  -r, --rebuild         Rebuild the container"
    echo ""
    echo "Arguments:"
    echo "  image_name_or_path    Either a template name or path to .devcontainer"
    echo "  workspace_path        Path to use as workspace (default: current directory)"
    echo ""
    echo "Available templates:"
    for img_dir in "$DEVCONTAINERS_DIR"/*; do
        if [ -d "$img_dir" ] && [ "$(basename "$img_dir")" != "common" ]; then
            echo "  - $(basename "$img_dir")"
        fi
    done
    echo ""
    echo "Examples:"
    echo "  vimcontainer dotnet .                    # Use dotnet template"
    echo "  vimcontainer dotnet ~/my-project         # Use dotnet template with project"
    exit 1
fi

# Resolve workspace path
WORKSPACE_PATH=$(readlink -f "$WORKSPACE_PATH")

# Determine if first argument is a path or template name
DEVCONTAINER_FOLDER=""
IMAGE_FEATURES_FILE=""

# Check if it's a path with .devcontainer folder (legacy mode)
RESOLVED_PATH=$(readlink -f "$IMAGE_NAME_OR_PATH" 2>/dev/null || echo "$IMAGE_NAME_OR_PATH")
if [ -d "$RESOLVED_PATH/.devcontainer" ]; then
    # Legacy mode: first argument is a path containing .devcontainer
    DEVCONTAINER_FOLDER="$RESOLVED_PATH/.devcontainer"
    IMAGE_NAME=$(basename "$RESOLVED_PATH")
    echo "Using custom .devcontainer from: $DEVCONTAINER_FOLDER"

    # Look for features.json in the same directory
    IMAGE_FEATURES_FILE="$RESOLVED_PATH/features.json"
    if [ ! -f "$IMAGE_FEATURES_FILE" ]; then
        echo "Warning: No features.json found at $IMAGE_FEATURES_FILE"
        echo "Creating minimal features.json for custom devcontainer"
        # Create a minimal features.json for custom devcontainers
        IMAGE_FEATURES_FILE="/tmp/vimcontainer-custom-features-$$.json"
        echo '{"localFeatures":[],"publicFeatures":{}}' > "$IMAGE_FEATURES_FILE"
    fi
elif [ -d "$RESOLVED_PATH" ] && [ -f "$RESOLVED_PATH/devcontainer.json" ]; then
    # Path points directly to .devcontainer folder
    DEVCONTAINER_FOLDER="$RESOLVED_PATH"
    IMAGE_NAME=$(basename $(dirname "$RESOLVED_PATH"))
    echo "Using custom .devcontainer from: $DEVCONTAINER_FOLDER"

    # Look for features.json in parent directory
    IMAGE_FEATURES_FILE="$(dirname "$RESOLVED_PATH")/features.json"
    if [ ! -f "$IMAGE_FEATURES_FILE" ]; then
        echo "Warning: No features.json found at $IMAGE_FEATURES_FILE"
        echo "Creating minimal features.json for custom devcontainer"
        IMAGE_FEATURES_FILE="/tmp/vimcontainer-custom-features-$$.json"
        echo '{"localFeatures":[],"publicFeatures":{}}' > "$IMAGE_FEATURES_FILE"
    fi
else
    # Template name mode: look up in devcontainers directory
    IMAGE_NAME="$IMAGE_NAME_OR_PATH"
    DEVCONTAINER_TEMPLATE="$DEVCONTAINERS_DIR/$IMAGE_NAME"

    if [ ! -d "$DEVCONTAINER_TEMPLATE" ]; then
        echo "Error: Template '$IMAGE_NAME' not found at $DEVCONTAINER_TEMPLATE"
        echo ""
        echo "Available templates:"
        for img_dir in "$DEVCONTAINERS_DIR"/*; do
            if [ -d "$img_dir" ] && [ "$(basename "$img_dir")" != "common" ]; then
                echo "  - $(basename "$img_dir")"
            fi
        done
        exit 1
    fi

    DEVCONTAINER_FOLDER="$DEVCONTAINER_TEMPLATE/.devcontainer"
    if [ ! -d "$DEVCONTAINER_FOLDER" ]; then
        echo "Error: No .devcontainer folder found in $DEVCONTAINER_TEMPLATE"
        exit 1
    fi

    IMAGE_FEATURES_FILE="$DEVCONTAINER_TEMPLATE/features.json"
    if [ ! -f "$IMAGE_FEATURES_FILE" ]; then
        echo "Error: No features.json found at $IMAGE_FEATURES_FILE"
        exit 1
    fi

    echo "Using template: $IMAGE_NAME"
fi

# Create temporary workspace with consistent name based on workspace path
# This ensures the same workspace always gets the same temp directory and container
WORKSPACE_HASH=$(echo -n "$WORKSPACE_PATH" | md5sum | cut -d' ' -f1 | cut -c1-8)
# Extract workspace name from path (basename) and sanitize for safe directory naming
WORKSPACE_NAME=$(basename "$WORKSPACE_PATH" | tr -cd '[:alnum:]._-')
TEMP_WORKSPACE="/tmp/vimcontainer-${WORKSPACE_HASH}"

# Rename tmux window to workspace name if running inside tmux
if [ -n "$TMUX" ]; then
    tmux rename-window "$WORKSPACE_NAME"
fi

# Clean up old temp workspace if it exists and we're rebuilding
if [ -n "$rebuild_flag" ] && [ -d "$TEMP_WORKSPACE" ]; then
    rm -rf "$TEMP_WORKSPACE"
    echo "Cleaned up old temporary workspace for rebuild"
fi

mkdir -p "$TEMP_WORKSPACE"
TEMP_DEVCONTAINER="$TEMP_WORKSPACE/.devcontainer"

echo "Using temporary workspace at: $TEMP_WORKSPACE"
echo "Source .devcontainer: $DEVCONTAINER_FOLDER"
echo "Workspace path: $WORKSPACE_PATH"

# Function to load and merge feature configurations
load_features_config() {
    # Load common features
    local common_local_features=()
    local common_public_features="{}"

    if [ -f "$COMMON_FEATURES_FILE" ]; then
        echo "Loading common features from $COMMON_FEATURES_FILE"

        # Extract local features array
        common_local_features=($(jq -r '.localFeatures[]?.name // empty' "$COMMON_FEATURES_FILE"))

        # Extract public features object
        common_public_features=$(jq -r '.publicFeatures // {}' "$COMMON_FEATURES_FILE")
    else
        echo "Warning: No common features file found at $COMMON_FEATURES_FILE"
    fi

    # Load image-specific features
    local image_local_features=()
    local image_public_features="{}"
    local post_create_cmd=""

    if [ -f "$IMAGE_FEATURES_FILE" ]; then
        echo "Loading image-specific features from $IMAGE_FEATURES_FILE"

        # Extract local features array
        image_local_features=($(jq -r '.localFeatures[]?.name // empty' "$IMAGE_FEATURES_FILE"))

        # Extract public features object
        image_public_features=$(jq -r '.publicFeatures // {}' "$IMAGE_FEATURES_FILE")

        # Extract postCreateCommand
        post_create_cmd=$(jq -r '.postCreateCommand // empty' "$IMAGE_FEATURES_FILE")
    fi

    # Merge local features (concatenate arrays)
    ALL_LOCAL_FEATURES=("${common_local_features[@]}" "${image_local_features[@]}")

    # Merge public features (image-specific overrides common)
    ALL_PUBLIC_FEATURES=$(jq -n --argjson common "$common_public_features" \
                                 --argjson specific "$image_public_features" \
                                 '$common + $specific')

    # Store postCreateCommand
    POST_CREATE_COMMAND="$post_create_cmd"

    echo "Merged features:"
    echo "  Local features: ${ALL_LOCAL_FEATURES[*]}"
    echo "  Public features count: $(echo "$ALL_PUBLIC_FEATURES" | jq 'length')"
    [ -n "$POST_CREATE_COMMAND" ] && echo "  Post-create command: $POST_CREATE_COMMAND"
}

# Call the function
load_features_config

# Only copy .devcontainer and features if they don't exist or if rebuilding
if [ ! -d "$TEMP_DEVCONTAINER" ] || [ -n "$rebuild_flag" ]; then
    echo "Setting up .devcontainer configuration..."

    # Remove old .devcontainer if it exists
    if [ -d "$TEMP_DEVCONTAINER" ]; then
        rm -rf "$TEMP_DEVCONTAINER"
    fi

    # Copy .devcontainer to temp location
    cp -r "$DEVCONTAINER_FOLDER" "$TEMP_DEVCONTAINER"

    # Copy local features to temp .devcontainer
    for feature_name in "${ALL_LOCAL_FEATURES[@]}"; do
        if [ -d "$PROJECT_ROOT/features/$feature_name" ]; then
            cp -r "$PROJECT_ROOT/features/$feature_name" "$TEMP_DEVCONTAINER/$feature_name"
            echo "Copied local feature: $feature_name"
        else
            echo "Warning: Feature '$feature_name' not found in $PROJECT_ROOT/features/"
        fi
    done

    # Build local features JSON for merging
    LOCAL_FEATURES_JSON="{}"
    for feature_name in "${ALL_LOCAL_FEATURES[@]}"; do
        # Get feature options from config files
        feature_options="{}"

        # Check common features config
        if [ -f "$COMMON_FEATURES_FILE" ]; then
            options=$(jq -r --arg name "$feature_name" \
                '.localFeatures[] | select(.name == $name) | .options // {}' \
                "$COMMON_FEATURES_FILE")
            [ "$options" != "" ] && feature_options="$options"
        fi

        # Check image-specific config (overrides common)
        if [ -f "$IMAGE_FEATURES_FILE" ]; then
            options=$(jq -r --arg name "$feature_name" \
                '.localFeatures[] | select(.name == $name) | .options // {}' \
                "$IMAGE_FEATURES_FILE")
            [ "$options" != "" ] && feature_options="$options"
        fi

        # Add to features JSON
        LOCAL_FEATURES_JSON=$(echo "$LOCAL_FEATURES_JSON" | \
            jq --arg path "./$feature_name" \
               --argjson opts "$feature_options" \
               '. + {($path): $opts}')
    done

    # Merge everything into devcontainer.json
    ORIGINAL_JSON="$TEMP_DEVCONTAINER/devcontainer.json"
    if [ -f "$ORIGINAL_JSON" ]; then
        # Add local features
        if [ "${#ALL_LOCAL_FEATURES[@]}" -gt 0 ]; then
            jq --argjson features "$LOCAL_FEATURES_JSON" \
               '.features += $features' \
               "$ORIGINAL_JSON" > "$ORIGINAL_JSON.tmp"
            mv "$ORIGINAL_JSON.tmp" "$ORIGINAL_JSON"
            echo "Merged ${#ALL_LOCAL_FEATURES[@]} local features into devcontainer.json"
        fi

        # Add postCreateCommand if specified and not already present
        if [ -n "$POST_CREATE_COMMAND" ]; then
            if ! jq -e '.postCreateCommand' "$ORIGINAL_JSON" > /dev/null 2>&1; then
                jq --arg cmd "$POST_CREATE_COMMAND" \
                   '.postCreateCommand = $cmd' \
                   "$ORIGINAL_JSON" > "$ORIGINAL_JSON.tmp"
                mv "$ORIGINAL_JSON.tmp" "$ORIGINAL_JSON"
                echo "Added postCreateCommand"
            fi
        fi

        echo "Merged features configuration into devcontainer.json"
    fi
else
    echo "Using existing .devcontainer configuration (use -r to rebuild)"
fi

# Get the Neovim config path (shared across all containers)
# Use LazyVim submodule from the project instead of user's config
LAZYVIM_PATH="$PROJECT_ROOT/submodules/LazyVim"

# Initialize submodule if not already done
if [ ! -d "$LAZYVIM_PATH/.git" ] && [ ! -f "$LAZYVIM_PATH/.git" ]; then
    echo "Initializing LazyVim submodule..."
    cd "$PROJECT_ROOT"
    git submodule update --init --recursive submodules/LazyVim
    cd - > /dev/null
fi

if [ ! -d "$LAZYVIM_PATH" ]; then
    echo "Error: LazyVim submodule not found at $LAZYVIM_PATH"
    echo "Please check your git submodule configuration"
    exit 1
fi

resolved_config_path=$(readlink -f "$LAZYVIM_PATH")
echo "Using LazyVim config from: $resolved_config_path"

# Get Claude Code auth paths from host
CLAUDE_AUTH_DIR="$HOME/.claude"
CLAUDE_AUTH_JSON="$HOME/.claude.json"

if [ ! -d "$CLAUDE_AUTH_DIR" ]; then
    echo "Warning: Claude Code auth directory not found at $CLAUDE_AUTH_DIR"
fi

if [ ! -f "$CLAUDE_AUTH_JSON" ]; then
    echo "Warning: Claude Code config file not found at $CLAUDE_AUTH_JSON"
fi

# Cleanup function - only clean up on interrupt/error, not on normal exit
cleanup() {
    # Only cleanup on interrupt (INT/TERM), not on normal exit
    # This preserves the temp workspace for container reuse
    if [ "$1" = "force" ]; then
        if [ -d "$TEMP_WORKSPACE" ]; then
            rm -rf "$TEMP_WORKSPACE"
            echo "Cleaned up temporary workspace"
        fi
    fi
}
trap 'cleanup force' INT TERM

# Construct the command to run the devcontainer

# ============================================================
# Workspace mounts priority handling
# ============================================================
# Read workspace's devcontainer.json mounts to avoid duplicates
# Workspace mounts take precedence over vimcontainer defaults

WORKSPACE_DEVCONTAINER_JSON="$WORKSPACE_PATH/.devcontainer/devcontainer.json"
WORKSPACE_MOUNT_TARGETS=()

# Function to extract target paths from mounts configuration
extract_mount_targets() {
    local json_file="$1"
    local targets=()
    
    if [ ! -f "$json_file" ]; then
        return
    fi
    
    # Check if mounts array exists
    local has_mounts
    has_mounts=$(jq -e '.mounts' "$json_file" 2>/dev/null)
    if [ $? -ne 0 ]; then
        return
    fi
    
    # Extract targets from mounts array
    # Supports both string format and object format:
    # - String format: "source=/path,target=/target,type=bind"
    # - Object format: {"source": "/path", "target": "/target", "type": "bind"}
    while IFS= read -r target; do
        if [ -n "$target" ] && [ "$target" != "null" ]; then
            targets+=("$target")
        fi
    done < <(jq -r '.mounts[] | 
        if type == "string" then
            # Parse string format: extract target value after "target="
            capture("target=(?<t>[^,]+)") | .t // empty
        elif type == "object" then
            # Object format: direct access to target field
            .target // empty
        else
            empty
        end' "$json_file" 2>/dev/null)
    
    # Output targets
    for t in "${targets[@]}"; do
        echo "$t"
    done
}

# Load workspace mount targets if devcontainer.json exists
if [ -f "$WORKSPACE_DEVCONTAINER_JSON" ]; then
    echo "Checking workspace devcontainer.json for mounts: $WORKSPACE_DEVCONTAINER_JSON"
    while IFS= read -r target; do
        if [ -n "$target" ]; then
            WORKSPACE_MOUNT_TARGETS+=("$target")
            echo "  Found workspace mount target: $target"
        fi
    done < <(extract_mount_targets "$WORKSPACE_DEVCONTAINER_JSON")
    
    if [ ${#WORKSPACE_MOUNT_TARGETS[@]} -gt 0 ]; then
        echo "Workspace defines ${#WORKSPACE_MOUNT_TARGETS[@]} mount(s) - these will take priority"
    fi
fi

# Function to check if a target path is already defined in workspace mounts
is_workspace_mount() {
    local target="$1"
    for ws_target in "${WORKSPACE_MOUNT_TARGETS[@]}"; do
        if [ "$ws_target" = "$target" ]; then
            return 0  # true: is a workspace mount
        fi
    done
    return 1  # false: not a workspace mount
}

# Function to add mount with workspace priority check
add_mount_with_priority() {
    local source="$1"
    local target="$2"
    local type="${3:-bind}"
    local description="${4:-}"
    
    if is_workspace_mount "$target"; then
        echo "  [SKIP] $target - already defined in workspace devcontainer.json"
        return 1
    fi
    
    if [ -n "$description" ]; then
        echo "  [ADD] $description"
    fi
    
    if [ "$type" = "volume" ]; then
        MOUNT_ARGS="$MOUNT_ARGS --mount type=volume,source=$source,target=$target"
    else
        MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$source,target=$target"
    fi
    return 0
}

# ============================================================
# Build mount arguments with workspace priority
# ============================================================
echo "Building mount arguments..."
MOUNT_ARGS=""

# Core workspace mounts
add_mount_with_priority "$WORKSPACE_PATH" "/workspaces/$(basename $WORKSPACE_PATH)" "bind" "Workspace: $WORKSPACE_PATH"
add_mount_with_priority "$resolved_config_path" "/home/vscode/.config/nvim" "bind" "Neovim config"
add_mount_with_priority "$PROJECT_ROOT/dotfiles/.tmux.conf" "/home/vscode/.tmux.conf" "bind" "tmux config"
add_mount_with_priority "$PROJECT_ROOT/dotfiles/.config/lazygit/config.yml" "/home/vscode/.config/lazygit/config.yml" "bind" "lazygit config"
add_mount_with_priority "$PROJECT_ROOT/scripts/start-tmux.sh" "/usr/local/bin/start-tmux" "bind" "start-tmux script"

# Add cplt command mount
add_mount_with_priority "$PROJECT_ROOT/bin/cplt" "/usr/local/bin/cplt" "bind" "cplt command"

# Add Copilot agents mount
add_mount_with_priority "$PROJECT_ROOT/agents" "/home/vscode/.copilot/agents" "bind" "Copilot agents directory"

# Add Copilot skills mount
add_mount_with_priority "$PROJECT_ROOT/skills" "/home/vscode/.copilot/skills" "bind" "Copilot skills directory"

# Add Copilot prompts mount
add_mount_with_priority "$PROJECT_ROOT/prompts" "/home/vscode/.copilot/prompts" "bind" "Copilot prompts directory"

# Add Copilot config mounts if they exist
COPILOT_DIR="$HOME/.copilot"

if [ -f "$COPILOT_DIR/mcp-config.json" ]; then
    add_mount_with_priority "$COPILOT_DIR/mcp-config.json" "/home/vscode/.copilot/mcp-config.json" "bind" "Copilot MCP config"
fi

if [ -f "$COPILOT_DIR/config.json" ]; then
    add_mount_with_priority "$COPILOT_DIR/config.json" "/home/vscode/.copilot/config.json" "bind" "Copilot config"
fi

# Note: Removed duplicate $COPILOT_DIR/skills mount to prevent "Duplicate mount point" error
# Project skills ($PROJECT_ROOT/skills) are already mounted above and take precedence

# Add agents-docs mount for document output
AGENTS_DOCS_DIR="$PROJECT_ROOT/agents-docs/${WORKSPACE_NAME}-${WORKSPACE_HASH}"
mkdir -p "$AGENTS_DOCS_DIR"
add_mount_with_priority "$AGENTS_DOCS_DIR" "/docs" "bind" "agents-docs directory"

# Add named volume for nvim data persistence
# Uses workspace-specific volume to keep nvim state independent per workspace
add_mount_with_priority "vimcontainer-setup-${WORKSPACE_HASH}" "/home/vscode/.local/share/nvim" "volume" "nvim data volume"

# Add Claude Code auth mounts if they exist
if [ -d "$CLAUDE_AUTH_DIR" ]; then
    add_mount_with_priority "$CLAUDE_AUTH_DIR" "/home/vscode/.claude" "bind" "Claude Code auth directory"
fi

if [ -f "$CLAUDE_AUTH_JSON" ]; then
    add_mount_with_priority "$CLAUDE_AUTH_JSON" "/home/vscode/.claude.json" "bind" "Claude Code config file"
fi

# Add gitconfig mount if it exists
if [ -f "$HOME/.gitconfig" ]; then
    add_mount_with_priority "$HOME/.gitconfig" "/home/vscode/.gitconfig" "bind" "gitconfig"
fi

# Add ssh directory mount if it exists
if [ -d "$HOME/.ssh" ]; then
    add_mount_with_priority "$HOME/.ssh" "/home/vscode/.ssh" "bind" "ssh directory"
fi

echo "Mount configuration complete."

command="devcontainer up $rebuild_flag --workspace-folder $TEMP_WORKSPACE $MOUNT_ARGS --remote-env DOCS_ROOT=/docs --remote-env PROJECT_NAME=$WORKSPACE_NAME --additional-features='$ALL_PUBLIC_FEATURES'"

eval "$command"
EXIT_CODE=$?

# Don't execute if devcontainer up failed
if [ $EXIT_CODE -eq 0 ]; then
    # Start tmux session with 3 windows (nvim, claude, bash)
    eval "devcontainer exec --workspace-folder $TEMP_WORKSPACE --remote-env DOCS_ROOT=/docs --remote-env PROJECT_NAME=$WORKSPACE_NAME start-tmux"
    # eval "devcontainer exec --workspace-folder $TEMP_WORKSPACE bash"
fi
