#!/bin/bash
# Absolute path to this script
SCRIPT=$(readlink -f "$0")
# Absolute path this script is in
SCRIPT_DIR=$(dirname "$SCRIPT")
# Project root directory (parent of bin/)
PROJECT_ROOT=$(dirname "$SCRIPT_DIR")
# Devcontainers templates directory
DEVCONTAINERS_DIR="$PROJECT_ROOT/devcontainers"
# Common features path
COMMON_FEATURES_FILE="$DEVCONTAINERS_DIR/common/features.json"

# Usage: vimcontainer [options] <image_name> <workspace_path>
# Options:
#   -r, --rebuild: Rebuild the container
#
# Arguments:
#   image_name: Name of the devcontainer template (e.g., 'dotnet', 'react')
#   workspace_path: Path to use as workspace in the container

# Parse arguments
rebuild_flag=""
while [[ "$1" =~ ^- ]]; do
    case "$1" in
        -r|--rebuild)
            rebuild_flag="--remove-existing-container"
            shift
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

IMAGE_NAME="$1"
WORKSPACE_PATH="${2:-.}"

# Validate arguments
if [ -z "$IMAGE_NAME" ]; then
    echo "Usage: vimcontainer [options] <image_name> [workspace_path]"
    echo ""
    echo "Options:"
    echo "  -r, --rebuild         Rebuild the container"
    echo ""
    echo "Arguments:"
    echo "  image_name            Name of devcontainer template (e.g., 'dotnet', 'react')"
    echo "  workspace_path        Path to use as workspace (default: current directory)"
    echo ""
    echo "Available images:"
    for img_dir in "$DEVCONTAINERS_DIR"/*; do
        if [ -d "$img_dir" ] && [ "$(basename "$img_dir")" != "common" ]; then
            echo "  - $(basename "$img_dir")"
        fi
    done
    exit 1
fi

# Resolve workspace path
WORKSPACE_PATH=$(readlink -f "$WORKSPACE_PATH")

# Resolve devcontainer template path
DEVCONTAINER_TEMPLATE="$DEVCONTAINERS_DIR/$IMAGE_NAME"
if [ ! -d "$DEVCONTAINER_TEMPLATE" ]; then
    echo "Error: Image '$IMAGE_NAME' not found at $DEVCONTAINER_TEMPLATE"
    echo ""
    echo "Available images:"
    for img_dir in "$DEVCONTAINERS_DIR"/*; do
        if [ -d "$img_dir" ] && [ "$(basename "$img_dir")" != "common" ]; then
            echo "  - $(basename "$img_dir")"
        fi
    done
    exit 1
fi

# Check for .devcontainer folder
DEVCONTAINER_FOLDER="$DEVCONTAINER_TEMPLATE/.devcontainer"
if [ ! -d "$DEVCONTAINER_FOLDER" ]; then
    echo "Error: No .devcontainer folder found in $DEVCONTAINER_TEMPLATE"
    exit 1
fi

# Check for features.json
IMAGE_FEATURES_FILE="$DEVCONTAINER_TEMPLATE/features.json"
if [ ! -f "$IMAGE_FEATURES_FILE" ]; then
    echo "Error: No features.json found at $IMAGE_FEATURES_FILE"
    exit 1
fi

# Create temporary workspace with consistent name based on workspace path
# This ensures the same workspace always gets the same temp directory and container
WORKSPACE_HASH=$(echo -n "$WORKSPACE_PATH" | md5sum | cut -d' ' -f1 | cut -c1-8)
TEMP_WORKSPACE="/tmp/vimcontainer-${WORKSPACE_HASH}"

# Clean up old temp workspace if it exists and we're rebuilding
if [ -n "$rebuild_flag" ] && [ -d "$TEMP_WORKSPACE" ]; then
    rm -rf "$TEMP_WORKSPACE"
    echo "Cleaned up old temporary workspace for rebuild"
fi

mkdir -p "$TEMP_WORKSPACE"
TEMP_DEVCONTAINER="$TEMP_WORKSPACE/.devcontainer"

echo "Using temporary workspace at: $TEMP_WORKSPACE"
echo "Source .devcontainer: $DEVCONTAINER_FOLDER"
echo "Workspace path: $WORKSPACE_PATH"

# Function to load and merge feature configurations
load_features_config() {
    # Load common features
    local common_local_features=()
    local common_public_features="{}"

    if [ -f "$COMMON_FEATURES_FILE" ]; then
        echo "Loading common features from $COMMON_FEATURES_FILE"

        # Extract local features array
        common_local_features=($(jq -r '.localFeatures[]?.name // empty' "$COMMON_FEATURES_FILE"))

        # Extract public features object
        common_public_features=$(jq -r '.publicFeatures // {}' "$COMMON_FEATURES_FILE")
    else
        echo "Warning: No common features file found at $COMMON_FEATURES_FILE"
    fi

    # Load image-specific features
    local image_local_features=()
    local image_public_features="{}"
    local post_create_cmd=""

    if [ -f "$IMAGE_FEATURES_FILE" ]; then
        echo "Loading image-specific features from $IMAGE_FEATURES_FILE"

        # Extract local features array
        image_local_features=($(jq -r '.localFeatures[]?.name // empty' "$IMAGE_FEATURES_FILE"))

        # Extract public features object
        image_public_features=$(jq -r '.publicFeatures // {}' "$IMAGE_FEATURES_FILE")

        # Extract postCreateCommand
        post_create_cmd=$(jq -r '.postCreateCommand // empty' "$IMAGE_FEATURES_FILE")
    fi

    # Merge local features (concatenate arrays)
    ALL_LOCAL_FEATURES=("${common_local_features[@]}" "${image_local_features[@]}")

    # Merge public features (image-specific overrides common)
    ALL_PUBLIC_FEATURES=$(jq -n --argjson common "$common_public_features" \
                                 --argjson specific "$image_public_features" \
                                 '$common + $specific')

    # Store postCreateCommand
    POST_CREATE_COMMAND="$post_create_cmd"

    echo "Merged features:"
    echo "  Local features: ${ALL_LOCAL_FEATURES[*]}"
    echo "  Public features count: $(echo "$ALL_PUBLIC_FEATURES" | jq 'length')"
    [ -n "$POST_CREATE_COMMAND" ] && echo "  Post-create command: $POST_CREATE_COMMAND"
}

# Call the function
load_features_config

# Only copy .devcontainer and features if they don't exist or if rebuilding
if [ ! -d "$TEMP_DEVCONTAINER" ] || [ -n "$rebuild_flag" ]; then
    echo "Setting up .devcontainer configuration..."

    # Remove old .devcontainer if it exists
    if [ -d "$TEMP_DEVCONTAINER" ]; then
        rm -rf "$TEMP_DEVCONTAINER"
    fi

    # Copy .devcontainer to temp location
    cp -r "$DEVCONTAINER_FOLDER" "$TEMP_DEVCONTAINER"

    # Copy local features to temp .devcontainer
    for feature_name in "${ALL_LOCAL_FEATURES[@]}"; do
        if [ -d "$PROJECT_ROOT/features/$feature_name" ]; then
            cp -r "$PROJECT_ROOT/features/$feature_name" "$TEMP_DEVCONTAINER/$feature_name"
            echo "Copied local feature: $feature_name"
        else
            echo "Warning: Feature '$feature_name' not found in $PROJECT_ROOT/features/"
        fi
    done

    # Build local features JSON for merging
    LOCAL_FEATURES_JSON="{}"
    for feature_name in "${ALL_LOCAL_FEATURES[@]}"; do
        # Get feature options from config files
        feature_options="{}"

        # Check common features config
        if [ -f "$COMMON_FEATURES_FILE" ]; then
            options=$(jq -r --arg name "$feature_name" \
                '.localFeatures[] | select(.name == $name) | .options // {}' \
                "$COMMON_FEATURES_FILE")
            [ "$options" != "" ] && feature_options="$options"
        fi

        # Check image-specific config (overrides common)
        if [ -f "$IMAGE_FEATURES_FILE" ]; then
            options=$(jq -r --arg name "$feature_name" \
                '.localFeatures[] | select(.name == $name) | .options // {}' \
                "$IMAGE_FEATURES_FILE")
            [ "$options" != "" ] && feature_options="$options"
        fi

        # Add to features JSON
        LOCAL_FEATURES_JSON=$(echo "$LOCAL_FEATURES_JSON" | \
            jq --arg path "./$feature_name" \
               --argjson opts "$feature_options" \
               '. + {($path): $opts}')
    done

    # Merge everything into devcontainer.json
    ORIGINAL_JSON="$TEMP_DEVCONTAINER/devcontainer.json"
    if [ -f "$ORIGINAL_JSON" ]; then
        # Add local features
        if [ "${#ALL_LOCAL_FEATURES[@]}" -gt 0 ]; then
            jq --argjson features "$LOCAL_FEATURES_JSON" \
               '.features += $features' \
               "$ORIGINAL_JSON" > "$ORIGINAL_JSON.tmp"
            mv "$ORIGINAL_JSON.tmp" "$ORIGINAL_JSON"
            echo "Merged ${#ALL_LOCAL_FEATURES[@]} local features into devcontainer.json"
        fi

        # Add postCreateCommand if specified and not already present
        if [ -n "$POST_CREATE_COMMAND" ]; then
            if ! jq -e '.postCreateCommand' "$ORIGINAL_JSON" > /dev/null 2>&1; then
                jq --arg cmd "$POST_CREATE_COMMAND" \
                   '.postCreateCommand = $cmd' \
                   "$ORIGINAL_JSON" > "$ORIGINAL_JSON.tmp"
                mv "$ORIGINAL_JSON.tmp" "$ORIGINAL_JSON"
                echo "Added postCreateCommand"
            fi
        fi

        echo "Merged features configuration into devcontainer.json"
    fi
else
    echo "Using existing .devcontainer configuration (use -r to rebuild)"
fi

# Get the Neovim config path (shared across all containers)
# Use LazyVim submodule from the project instead of user's config
LAZYVIM_PATH="$PROJECT_ROOT/submodules/LazyVim"

# Initialize submodule if not already done
if [ ! -d "$LAZYVIM_PATH/.git" ] && [ ! -f "$LAZYVIM_PATH/.git" ]; then
    echo "Initializing LazyVim submodule..."
    cd "$PROJECT_ROOT"
    git submodule update --init --recursive submodules/LazyVim
    cd - > /dev/null
fi

if [ ! -d "$LAZYVIM_PATH" ]; then
    echo "Error: LazyVim submodule not found at $LAZYVIM_PATH"
    echo "Please check your git submodule configuration"
    exit 1
fi

resolved_config_path=$(readlink -f "$LAZYVIM_PATH")
echo "Using LazyVim config from: $resolved_config_path"

# Get Claude Code auth paths from host
CLAUDE_AUTH_DIR="$HOME/.claude"
CLAUDE_AUTH_JSON="$HOME/.claude.json"

if [ ! -d "$CLAUDE_AUTH_DIR" ]; then
    echo "Warning: Claude Code auth directory not found at $CLAUDE_AUTH_DIR"
fi

if [ ! -f "$CLAUDE_AUTH_JSON" ]; then
    echo "Warning: Claude Code config file not found at $CLAUDE_AUTH_JSON"
fi

# Cleanup function - only clean up on interrupt/error, not on normal exit
cleanup() {
    # Only cleanup on interrupt (INT/TERM), not on normal exit
    # This preserves the temp workspace for container reuse
    if [ "$1" = "force" ]; then
        if [ -d "$TEMP_WORKSPACE" ]; then
            rm -rf "$TEMP_WORKSPACE"
            echo "Cleaned up temporary workspace"
        fi
    fi
}
trap 'cleanup force' INT TERM

# Construct the command to run the devcontainer
MOUNT_ARGS=""
MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$WORKSPACE_PATH,target=/workspaces/$(basename $WORKSPACE_PATH)"
MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$resolved_config_path,target=/home/vscode/.config/nvim"
MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$PROJECT_ROOT/dotfiles/.tmux.conf,target=/home/vscode/.tmux.conf"
MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$PROJECT_ROOT/scripts/start-tmux.sh,target=/usr/local/bin/start-tmux"

# Add Claude Code auth mounts if they exist
if [ -d "$CLAUDE_AUTH_DIR" ]; then
    echo "Mounting Claude Code auth directory: $CLAUDE_AUTH_DIR"
    MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$CLAUDE_AUTH_DIR,target=/home/vscode/.claude"
fi

if [ -f "$CLAUDE_AUTH_JSON" ]; then
    echo "Mounting Claude Code config file: $CLAUDE_AUTH_JSON"
    MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$CLAUDE_AUTH_JSON,target=/home/vscode/.claude.json"
fi

command="devcontainer up $rebuild_flag --workspace-folder $TEMP_WORKSPACE $MOUNT_ARGS --additional-features='$ALL_PUBLIC_FEATURES'"

eval "$command"
EXIT_CODE=$?

# Don't execute if devcontainer up failed
if [ $EXIT_CODE -eq 0 ]; then
    # Start tmux session with 3 windows (nvim, claude, bash)
    eval "devcontainer exec --workspace-folder $TEMP_WORKSPACE start-tmux"
    # eval "devcontainer exec --workspace-folder $TEMP_WORKSPACE bash"
fi
