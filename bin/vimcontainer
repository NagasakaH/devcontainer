#!/bin/bash
# Absolute path to this script
SCRIPT=$(readlink -f "$0")
# Absolute path this script is in
SCRIPT_DIR=$(dirname "$SCRIPT")
# Project root directory (parent of bin/)
PROJECT_ROOT=$(dirname "$SCRIPT_DIR")
# Devcontainers templates directory
DEVCONTAINERS_DIR="$PROJECT_ROOT/devcontainers"
# Common features path
COMMON_FEATURES_FILE="$DEVCONTAINERS_DIR/common/features.json"

# Usage: vimcontainer [options] <image_name> <workspace_path>
#        vimcontainer [options] <image_name_or_path> [workspace_path]
# Options:
#   -r, --rebuild: Rebuild the container
#
# Arguments:
#   image_name_or_path: Either:
#                       - Name of devcontainer template (e.g., 'dotnet', 'react')
#                       - Path containing .devcontainer folder (legacy mode)
#   workspace_path: Path to use as workspace in the container (default: current directory)
#
# Examples:
#   vimcontainer dotnet .                    # Use dotnet template with current dir
#   vimcontainer dotnet ~/my-project         # Use dotnet template with specified project
#   vimcontainer ~/custom/.devcontainer ~/project  # Use custom devcontainer (legacy)

# Parse arguments
rebuild_flag=""
while [[ "$1" =~ ^- ]]; do
    case "$1" in
        -r|--rebuild)
            rebuild_flag="--remove-existing-container"
            shift
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

IMAGE_NAME_OR_PATH="$1"
WORKSPACE_PATH="${2:-.}"

# Validate arguments
if [ -z "$IMAGE_NAME_OR_PATH" ]; then
    echo "Usage: vimcontainer [options] <image_name_or_path> [workspace_path]"
    echo ""
    echo "Options:"
    echo "  -r, --rebuild         Rebuild the container"
    echo ""
    echo "Arguments:"
    echo "  image_name_or_path    Either a template name or path to .devcontainer"
    echo "  workspace_path        Path to use as workspace (default: current directory)"
    echo ""
    echo "Available templates:"
    for img_dir in "$DEVCONTAINERS_DIR"/*; do
        if [ -d "$img_dir" ] && [ "$(basename "$img_dir")" != "common" ]; then
            echo "  - $(basename "$img_dir")"
        fi
    done
    echo ""
    echo "Examples:"
    echo "  vimcontainer dotnet .                    # Use dotnet template"
    echo "  vimcontainer dotnet ~/my-project         # Use dotnet template with project"
    exit 1
fi

# Resolve workspace path
WORKSPACE_PATH=$(readlink -f "$WORKSPACE_PATH")

# Determine if first argument is a path or template name
DEVCONTAINER_FOLDER=""
IMAGE_FEATURES_FILE=""

# Check if it's a path with .devcontainer folder (legacy mode)
RESOLVED_PATH=$(readlink -f "$IMAGE_NAME_OR_PATH" 2>/dev/null || echo "$IMAGE_NAME_OR_PATH")
if [ -d "$RESOLVED_PATH/.devcontainer" ]; then
    # Legacy mode: first argument is a path containing .devcontainer
    DEVCONTAINER_FOLDER="$RESOLVED_PATH/.devcontainer"
    IMAGE_NAME=$(basename "$RESOLVED_PATH")
    echo "Using custom .devcontainer from: $DEVCONTAINER_FOLDER"

    # Look for features.json in the same directory
    IMAGE_FEATURES_FILE="$RESOLVED_PATH/features.json"
    if [ ! -f "$IMAGE_FEATURES_FILE" ]; then
        echo "Warning: No features.json found at $IMAGE_FEATURES_FILE"
        echo "Creating minimal features.json for custom devcontainer"
        # Create a minimal features.json for custom devcontainers
        IMAGE_FEATURES_FILE="/tmp/vimcontainer-custom-features-$$.json"
        echo '{"localFeatures":[],"publicFeatures":{}}' > "$IMAGE_FEATURES_FILE"
    fi
elif [ -d "$RESOLVED_PATH" ] && [ -f "$RESOLVED_PATH/devcontainer.json" ]; then
    # Path points directly to .devcontainer folder
    DEVCONTAINER_FOLDER="$RESOLVED_PATH"
    IMAGE_NAME=$(basename $(dirname "$RESOLVED_PATH"))
    echo "Using custom .devcontainer from: $DEVCONTAINER_FOLDER"

    # Look for features.json in parent directory
    IMAGE_FEATURES_FILE="$(dirname "$RESOLVED_PATH")/features.json"
    if [ ! -f "$IMAGE_FEATURES_FILE" ]; then
        echo "Warning: No features.json found at $IMAGE_FEATURES_FILE"
        echo "Creating minimal features.json for custom devcontainer"
        IMAGE_FEATURES_FILE="/tmp/vimcontainer-custom-features-$$.json"
        echo '{"localFeatures":[],"publicFeatures":{}}' > "$IMAGE_FEATURES_FILE"
    fi
else
    # Template name mode: look up in devcontainers directory
    IMAGE_NAME="$IMAGE_NAME_OR_PATH"
    DEVCONTAINER_TEMPLATE="$DEVCONTAINERS_DIR/$IMAGE_NAME"

    if [ ! -d "$DEVCONTAINER_TEMPLATE" ]; then
        echo "Error: Template '$IMAGE_NAME' not found at $DEVCONTAINER_TEMPLATE"
        echo ""
        echo "Available templates:"
        for img_dir in "$DEVCONTAINERS_DIR"/*; do
            if [ -d "$img_dir" ] && [ "$(basename "$img_dir")" != "common" ]; then
                echo "  - $(basename "$img_dir")"
            fi
        done
        exit 1
    fi

    DEVCONTAINER_FOLDER="$DEVCONTAINER_TEMPLATE/.devcontainer"
    if [ ! -d "$DEVCONTAINER_FOLDER" ]; then
        echo "Error: No .devcontainer folder found in $DEVCONTAINER_TEMPLATE"
        exit 1
    fi

    IMAGE_FEATURES_FILE="$DEVCONTAINER_TEMPLATE/features.json"
    if [ ! -f "$IMAGE_FEATURES_FILE" ]; then
        echo "Error: No features.json found at $IMAGE_FEATURES_FILE"
        exit 1
    fi

    echo "Using template: $IMAGE_NAME"
fi

# Create temporary workspace with consistent name based on workspace path
# This ensures the same workspace always gets the same temp directory and container
WORKSPACE_HASH=$(echo -n "$WORKSPACE_PATH" | md5sum | cut -d' ' -f1 | cut -c1-8)
# Extract workspace name from path (basename) and sanitize for safe directory naming
WORKSPACE_NAME=$(basename "$WORKSPACE_PATH" | tr -cd '[:alnum:]._-')
TEMP_WORKSPACE="/tmp/vimcontainer-${WORKSPACE_HASH}"

# Rename tmux window to workspace name if running inside tmux
if [ -n "$TMUX" ]; then
    tmux rename-window "$WORKSPACE_NAME"
fi

# Clean up old temp workspace if it exists and we're rebuilding
if [ -n "$rebuild_flag" ] && [ -d "$TEMP_WORKSPACE" ]; then
    rm -rf "$TEMP_WORKSPACE"
    echo "Cleaned up old temporary workspace for rebuild"
fi

mkdir -p "$TEMP_WORKSPACE"
TEMP_DEVCONTAINER="$TEMP_WORKSPACE/.devcontainer"

echo "Using temporary workspace at: $TEMP_WORKSPACE"
echo "Source .devcontainer: $DEVCONTAINER_FOLDER"
echo "Workspace path: $WORKSPACE_PATH"

# Function to load and merge feature configurations
load_features_config() {
    # Load common features
    local common_local_features=()
    local common_public_features="{}"

    if [ -f "$COMMON_FEATURES_FILE" ]; then
        echo "Loading common features from $COMMON_FEATURES_FILE"

        # Extract local features array
        common_local_features=($(jq -r '.localFeatures[]?.name // empty' "$COMMON_FEATURES_FILE"))

        # Extract public features object
        common_public_features=$(jq -r '.publicFeatures // {}' "$COMMON_FEATURES_FILE")
    else
        echo "Warning: No common features file found at $COMMON_FEATURES_FILE"
    fi

    # Load image-specific features
    local image_local_features=()
    local image_public_features="{}"
    local post_create_cmd=""

    if [ -f "$IMAGE_FEATURES_FILE" ]; then
        echo "Loading image-specific features from $IMAGE_FEATURES_FILE"

        # Extract local features array
        image_local_features=($(jq -r '.localFeatures[]?.name // empty' "$IMAGE_FEATURES_FILE"))

        # Extract public features object
        image_public_features=$(jq -r '.publicFeatures // {}' "$IMAGE_FEATURES_FILE")

        # Extract postCreateCommand
        post_create_cmd=$(jq -r '.postCreateCommand // empty' "$IMAGE_FEATURES_FILE")
    fi

    # Merge local features (concatenate arrays)
    ALL_LOCAL_FEATURES=("${common_local_features[@]}" "${image_local_features[@]}")

    # Merge public features (image-specific overrides common)
    ALL_PUBLIC_FEATURES=$(jq -n --argjson common "$common_public_features" \
                                 --argjson specific "$image_public_features" \
                                 '$common + $specific')

    # Store postCreateCommand
    POST_CREATE_COMMAND="$post_create_cmd"

    echo "Merged features:"
    echo "  Local features: ${ALL_LOCAL_FEATURES[*]}"
    echo "  Public features count: $(echo "$ALL_PUBLIC_FEATURES" | jq 'length')"
    [ -n "$POST_CREATE_COMMAND" ] && echo "  Post-create command: $POST_CREATE_COMMAND"
}

# Call the function
load_features_config

# Only copy .devcontainer and features if they don't exist or if rebuilding
if [ ! -d "$TEMP_DEVCONTAINER" ] || [ -n "$rebuild_flag" ]; then
    echo "Setting up .devcontainer configuration..."

    # Remove old .devcontainer if it exists
    if [ -d "$TEMP_DEVCONTAINER" ]; then
        rm -rf "$TEMP_DEVCONTAINER"
    fi

    # Copy .devcontainer to temp location
    cp -r "$DEVCONTAINER_FOLDER" "$TEMP_DEVCONTAINER"

    # Copy local features to temp .devcontainer
    for feature_name in "${ALL_LOCAL_FEATURES[@]}"; do
        if [ -d "$PROJECT_ROOT/features/$feature_name" ]; then
            cp -r "$PROJECT_ROOT/features/$feature_name" "$TEMP_DEVCONTAINER/$feature_name"
            echo "Copied local feature: $feature_name"
        else
            echo "Warning: Feature '$feature_name' not found in $PROJECT_ROOT/features/"
        fi
    done

    # Build local features JSON for merging
    LOCAL_FEATURES_JSON="{}"
    for feature_name in "${ALL_LOCAL_FEATURES[@]}"; do
        # Get feature options from config files
        feature_options="{}"

        # Check common features config
        if [ -f "$COMMON_FEATURES_FILE" ]; then
            options=$(jq -r --arg name "$feature_name" \
                '.localFeatures[] | select(.name == $name) | .options // {}' \
                "$COMMON_FEATURES_FILE")
            [ "$options" != "" ] && feature_options="$options"
        fi

        # Check image-specific config (overrides common)
        if [ -f "$IMAGE_FEATURES_FILE" ]; then
            options=$(jq -r --arg name "$feature_name" \
                '.localFeatures[] | select(.name == $name) | .options // {}' \
                "$IMAGE_FEATURES_FILE")
            [ "$options" != "" ] && feature_options="$options"
        fi

        # Add to features JSON
        LOCAL_FEATURES_JSON=$(echo "$LOCAL_FEATURES_JSON" | \
            jq --arg path "./$feature_name" \
               --argjson opts "$feature_options" \
               '. + {($path): $opts}')
    done

    # Merge everything into devcontainer.json
    ORIGINAL_JSON="$TEMP_DEVCONTAINER/devcontainer.json"
    if [ -f "$ORIGINAL_JSON" ]; then
        # Add local features
        if [ "${#ALL_LOCAL_FEATURES[@]}" -gt 0 ]; then
            jq --argjson features "$LOCAL_FEATURES_JSON" \
               '.features += $features' \
               "$ORIGINAL_JSON" > "$ORIGINAL_JSON.tmp"
            mv "$ORIGINAL_JSON.tmp" "$ORIGINAL_JSON"
            echo "Merged ${#ALL_LOCAL_FEATURES[@]} local features into devcontainer.json"
        fi

        # Add postCreateCommand if specified and not already present
        if [ -n "$POST_CREATE_COMMAND" ]; then
            if ! jq -e '.postCreateCommand' "$ORIGINAL_JSON" > /dev/null 2>&1; then
                jq --arg cmd "$POST_CREATE_COMMAND" \
                   '.postCreateCommand = $cmd' \
                   "$ORIGINAL_JSON" > "$ORIGINAL_JSON.tmp"
                mv "$ORIGINAL_JSON.tmp" "$ORIGINAL_JSON"
                echo "Added postCreateCommand"
            fi
        fi

        echo "Merged features configuration into devcontainer.json"
    fi
else
    echo "Using existing .devcontainer configuration (use -r to rebuild)"
fi

# Get the Neovim config path (shared across all containers)
# Use LazyVim submodule from the project instead of user's config
LAZYVIM_PATH="$PROJECT_ROOT/submodules/LazyVim"

# Initialize submodule if not already done
if [ ! -d "$LAZYVIM_PATH/.git" ] && [ ! -f "$LAZYVIM_PATH/.git" ]; then
    echo "Initializing LazyVim submodule..."
    cd "$PROJECT_ROOT"
    git submodule update --init --recursive submodules/LazyVim
    cd - > /dev/null
fi

if [ ! -d "$LAZYVIM_PATH" ]; then
    echo "Error: LazyVim submodule not found at $LAZYVIM_PATH"
    echo "Please check your git submodule configuration"
    exit 1
fi

resolved_config_path=$(readlink -f "$LAZYVIM_PATH")
echo "Using LazyVim config from: $resolved_config_path"

# Get Claude Code auth paths from host
CLAUDE_AUTH_DIR="$HOME/.claude"
CLAUDE_AUTH_JSON="$HOME/.claude.json"

if [ ! -d "$CLAUDE_AUTH_DIR" ]; then
    echo "Warning: Claude Code auth directory not found at $CLAUDE_AUTH_DIR"
fi

if [ ! -f "$CLAUDE_AUTH_JSON" ]; then
    echo "Warning: Claude Code config file not found at $CLAUDE_AUTH_JSON"
fi

# Cleanup function - only clean up on interrupt/error, not on normal exit
cleanup() {
    # Only cleanup on interrupt (INT/TERM), not on normal exit
    # This preserves the temp workspace for container reuse
    if [ "$1" = "force" ]; then
        if [ -d "$TEMP_WORKSPACE" ]; then
            rm -rf "$TEMP_WORKSPACE"
            echo "Cleaned up temporary workspace"
        fi
    fi
}
trap 'cleanup force' INT TERM

# Construct the command to run the devcontainer
MOUNT_ARGS=""
MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$WORKSPACE_PATH,target=/workspaces/$(basename $WORKSPACE_PATH)"
MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$resolved_config_path,target=/home/vscode/.config/nvim"
MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$PROJECT_ROOT/dotfiles/.tmux.conf,target=/home/vscode/.tmux.conf"
MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$PROJECT_ROOT/scripts/start-tmux.sh,target=/usr/local/bin/start-tmux"

# Add cplt command mount
MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$PROJECT_ROOT/bin/cplt,target=/usr/local/bin/cplt"

# Add Copilot agents mount
echo "Mounting Copilot agents directory: $PROJECT_ROOT/agents"
MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$PROJECT_ROOT/agents,target=/home/vscode/.copilot/agents"

# Add Copilot config mounts if they exist
COPILOT_DIR="$HOME/.copilot"

if [ -f "$COPILOT_DIR/mcp-config.json" ]; then
    echo "Mounting Copilot MCP config: $COPILOT_DIR/mcp-config.json"
    MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$COPILOT_DIR/mcp-config.json,target=/home/vscode/.copilot/mcp-config.json"
fi

if [ -f "$COPILOT_DIR/config.json" ]; then
    echo "Mounting Copilot config: $COPILOT_DIR/config.json"
    MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$COPILOT_DIR/config.json,target=/home/vscode/.copilot/config.json"
fi

if [ -d "$COPILOT_DIR/skills" ]; then
    echo "Mounting Copilot skills directory: $COPILOT_DIR/skills"
    MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$COPILOT_DIR/skills,target=/home/vscode/.copilot/skills"
fi

# Add agents-docs mount for document output
AGENTS_DOCS_DIR="$PROJECT_ROOT/agents-docs/${WORKSPACE_NAME}-${WORKSPACE_HASH}"
mkdir -p "$AGENTS_DOCS_DIR"
echo "Mounting agents-docs directory: $AGENTS_DOCS_DIR"
MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$AGENTS_DOCS_DIR,target=/docs"

# Add named volume for nvim data persistence
# Uses workspace-specific volume to keep nvim state independent per workspace
MOUNT_ARGS="$MOUNT_ARGS --mount type=volume,source=vimcontainer-setup-${WORKSPACE_HASH},target=/home/vscode/.local/share/nvim"

# Add Claude Code auth mounts if they exist
if [ -d "$CLAUDE_AUTH_DIR" ]; then
    echo "Mounting Claude Code auth directory: $CLAUDE_AUTH_DIR"
    MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$CLAUDE_AUTH_DIR,target=/home/vscode/.claude"
fi

if [ -f "$CLAUDE_AUTH_JSON" ]; then
    echo "Mounting Claude Code config file: $CLAUDE_AUTH_JSON"
    MOUNT_ARGS="$MOUNT_ARGS --mount type=bind,source=$CLAUDE_AUTH_JSON,target=/home/vscode/.claude.json"
fi

command="devcontainer up $rebuild_flag --workspace-folder $TEMP_WORKSPACE $MOUNT_ARGS --remote-env DOCS_ROOT=/docs --remote-env PROJECT_NAME=$WORKSPACE_NAME --additional-features='$ALL_PUBLIC_FEATURES'"

eval "$command"
EXIT_CODE=$?

# Don't execute if devcontainer up failed
if [ $EXIT_CODE -eq 0 ]; then
    # Start tmux session with 3 windows (nvim, claude, bash)
    eval "devcontainer exec --workspace-folder $TEMP_WORKSPACE --remote-env DOCS_ROOT=/docs --remote-env PROJECT_NAME=$WORKSPACE_NAME start-tmux"
    # eval "devcontainer exec --workspace-folder $TEMP_WORKSPACE bash"
fi
